# Extending a Grammar

## Contents

- [Arsenal Grammar](#arsenal-grammar)
- [The Grammar File](#the-grammar-file)
- [The Pretty-Printing File](#the-pretty-printing-file)
- [Conclusion](#conclusion)

## Arsenal Grammar

An Arsenal grammar specifies the form of syntax trees modeling concepts and relations between concepts that together describe an application domain.  

A grammar is declared using the [OCaml programming language](https://ocaml.org/), in an [OCaml module file](https://ocaml.org/learn/tutorials/modules.html#Basic-usage) with the standard file extension `.ml`. 

> The [`REgrammar.ml`](../regexp/generate-reformulate/src/REgrammar.ml) module file provides an example of a grammar declared for a regular expression example.

In Arsenal, the relation between syntax trees and natural language (NL) is based on encodings from syntax trees to NL sentences called "pretty printing" (PP or pp).  Such pretty-print encodings are coded as functions, in `.ml` pretty-printing files associated with `.ml` grammar files.  

> The [`REgrammar_pp.ml`](../regexp/generate-reformulate/src/REgrammar.ml) module file provides an example of a pretty-print encoding for the grammar declared for regular expressions in the `REgrammar.ml` module file.

<!-- Both files are particular cases of source code files for the programming
language ocaml, which are all `.ml` files. No advanced ocaml programming skills is
required to write an Arsenal grammar, or the pretty-printing functions for it. -->

Note that *no advanced OCaml programming skills are required* to declare an Arsenal grammar or to code its pretty-printing functions.  

The sections below describe first, the contents of an Arsenal [grammar file](#the-grammar-file), and second, the contents of a [pretty-printing file](#the-pretty-printing-file).

## The Grammar File

- [Libraries](#libraries)
- [Entity Kind Declarations](#entity-kind-declarations)
- [Types for Syntax Trees](#types-for-syntax-trees)

> Most of the examples in the following sections are taken from the [`REgrammar.ml`](../regexp/generator-reformulate/src/REgrammar.ml) file.

### Libraries

The grammar file begins with the following statements:

```ocaml
open Format
open Sexplib
open Std
open Arsenal_lib
```

These `open` statements load libraries required by Arsenal.  
The first three load open-source libraries:
- [Format](https://opam.ocaml.org/packages/format/) for support for formatting print output
- [Sexplib](https://opam.ocaml.org/packages/sexplib/) for serializing syntax trees as S-expressions.  
- [Std](https://opam.ocaml.org/packages) for standard library support.
The fourth loads the Arsenal library including domain-agnostic grammar with basic English-language constructs; all Arsenal grammars extend this basic grammar.

The source code for the Arsenal libraries is in the `../ocaml-grammars/arsenal_lib/src` directory but can be accessed as an importable package.

### Entity Declarations

In the Arsenal pipeline, terms or phrases mentioning entities as defined in the grammar are detected and indicated in spans of NL sentences by an Entity Processor 
for the specific application domain. The regular expression example defines two kinds of entity substitions - characters and strings. 

In the regexp example, the regexp-entity provides a rudimentary regular expression entity processor that looks for quoted single characters or quoted strings
within the NL input text and flags them as one of the two defined entity types.

When the NL to CST module is invoked after the Entity Processor in the Arsenal pipeline, these spans will have mentions of entity types replaced by 
"entity placeholders", each of which has:
  - a keyword or "flag" for a mention of the entity type
  - a positive-integer index appended to the flag, uniquely identifying the mention in a series of the entity type

For example, when the NL sentence:

>  any character between 'a' and 'b'

is given as "original text" input to the Entity Processor, the "new text" output generated by the entity processor is:

>  any character between Char_1 and Char_2

where:
 - `Char_1` (the first mention of an entity) is 'a'
 - `Char_2` (the second mention) is 'b'

In this example, the entity types are defined in the following declarations:
 
 ```ocaml
type kchar = Char [@@deriving arsenal, show { with_path = false }]
type kstring = String [@@deriving arsenal, show { with_path = false }]

type tchar = kchar Entity.t     [@@deriving arsenal]
type tstring = kstring Entity.t [@@deriving arsenal]
 ```
 
The last part of each line - i.e. `[@@deriving arsenal]` or `[@@deriving arsenal, show { with_path = false }]` - again instructs Arsenal to process the type declaration.

### Types for Syntax Trees
- [Syntax Tree Type Constructors](#syntax-tree-type-constructors)
- [Weightings for Randomly Generating Syntax Trees](#weightings-for-randomly-generating-syntax-trees)
- [Built-In Types](#built-in-types)
- [Entity Types](#entity-types)

#### Syntax Tree Type Constructors

After the entity types are declared, the grammar file describes the syntax tree
grammar *per se*. This description involves the standard notion of context-free grammar, which can be viewed as the signature of term symbols in typed first-order logic. 
 The grammar is made of a number of types that are *syntactic categories*.  Each valid syntax tree belongs to a syntactic category -
i.e. has a type, or "inhabits" that type.

The grammar file consists of a series of syntax tree node type declarations, for example:

```ocaml
type mytype = C_one | C_two of othertype*othertype | C_three of othertype*mytype
[@@deriving arsenal]
```
Each type is declared with a name (here `mytype`) and a number of rules
(here three), each of which declares one way of inhabiting the
type.  Here, the rules are separated by the pipe symbol `|`, which again indicates a type meet or disjunction, so that the type `mytype` is again a union type.  

Each rule introduces a symbol called *constructor* - here, `C_one`,
`C_two`, `C_three`. In a syntax tree, each node is associated with one of these
constructors and is of the corresponding type. Here, any syntax tree whose root node associated with `C_one`, `C_two`, or `C_three` is of type `mytype`. 

A rule introducing a constructor for a syntax tree node continues to give a list of types of children that a node associated with the constructor must have.
This list follows the keyword `of`, and separates types of children (when there are two or more) with `*`.
The node must have has as many children as specified by the rule.  Here:
- nodes associated with `C_one` have no children - because there is no `of` or list in the rule introducing `C_one` - and so are "leaf-level" nodes
- nodes associated with `C_two` have two children, both of type `othertype` 
- nodes associated with `C_three` also have two children, one of type `othertype` and one of type `mytype` 

Note that, as with `mytype`, a child node can have the same type as its parent, and, as with `othertype`, can have a type defined elsewhere in the grammar file. 

Again, a type declaration is always followed by `[@@deriving arsenal]`, to
instruct Arsenal to process the declaration.

When defining node types, note that:
- type (and variable) names always start with a lowercase letter - e.g. `mytype`
- constructor names always start with an uppercase letter - e.g. `C_one`
- the same constructor name *cannot* be reused in different type declarations

The [`base_grammar`](../ocaml-grammars/arsenal_lib/src/base_grammar.ml) library  offers a few examples of generic grammar types.

#### Weightings for Randomly Generating Syntax Trees

One of the tasks performed by the `[@@deriving arsenal]` invocation at the end of
a type declaration `type mytype = ...` is to create automatically a function
`sexp_of_mytype` that serializes syntax trees of type `mytype` into
S-expressions. That function is not seen explicitly in the grammar file because
it is automatically generated; however, it can be used anywhere after this type
declaration.

Similarly, another task is to create a function `random_mytype` that generates a
random syntax tree of type `mytype`. *Per* the type declaration above, it 
randomly picks a number, with uniform probability, between 1, 2 and 3, and start
the construction of a syntax tree whose root is, respectively, `C_one`, `C_two`,
or `C_three`. In case of `C_one`, the random generation function stops there, as
the syntax tree is complete, so that a node associated with `C_one` is a *leaf node*. In case of `C_two`, the random generation function
recursively calls upon the random generation function associated with type
`othertype`, twice: once to generate the first child, once to generate
the second child. In case of `C_three`, the random generation function
recursively calls the random generation function associated with type
`othertype`, for the first child, and calls itself recursively to generate the
second child.

The grammar developer may wish to bias the generation of a syntax tree,
anticipating that it may be useful to generate more often, say, syntax trees of
root `C_one`, than syntax trees of root `C_two`. Such a bias can be specified by
indicating a weight for each rule (i.e. each constructor) of the type
declaration, e.g.:
```ocaml
type mytype = C_one [@weight 5] | C_two of othertype*othertype [@weight 3] | C_three of othertype*mytype
[@@deriving arsenal]
```

Here, `C_one` is picked with probability 5/9, `C_two` is picked with probability
3/9, and `C_three` is picked with probability 1/9 (1 is the default weight when
not indicated). More information about biasing the random generation can be
found on the homepage of the `ppx_deriving_random` plugin:
https://github.com/disteph/ppx_deriving_random

#### Built-In Types

Besides the types defined in the base grammar, there are the following grammar types built in to OCaml. 

- type `int` (for integer values)

- type `bool` (for Boolean values)

- for each type `'a`, a type `'a option`. The (built-in) type declaration for it is
  ```ocaml
  type 'a option = None | Some of 'a
  ```
  An option type models syntax trees that may or may not contain a tree of type `'a`, and    is convenient to use it for declaring arguments of constructors that are
  optional (may or may not be there).

- for each type `'a`, a type `'a list`. The (built-in) type declaration for it is
  ```ocaml
  type 'a list = Nil | Cons of 'a*(`a list)
  ```
  A list type models syntax trees that are lists of trees of type `'a`, with `Nil`
  representing the empty list, and `Cons(t,l)` (usually abbreviated `t::l`),
  representing the list of head as `t` and the list tail as `l`.

These type declarations do not come with random generation biases, because such biases
are up to the user of the built-in types. Instead, when the user declares a
constructor, one of whose arguments is (say) of type `othertype option`, they can specify with which probability `None` and `Some(tree)` is
generated. An example of how this might look is:

```ocaml
type action =
  | Action_Recommend of restaurant
  | Action_Dish      of recipe
  | Action_Try       of food
  | Action_Test      of location option [@random random_location +? 0.6]
[@@deriving arsenal]
```
Here, the constructor `Action_Test` expects one optional argument, of type
`location`.  Writing `[@random random_location +? 0.6]` just after the keyword `option`
indicates that, with probability 0.6, `None` is picked (i.e. the absence of
argument), and with probability 0.4, `Some(t)` is generated, using the 
`random_location` function to generate `t` of type `location`.

In the following type declaration:

```ocaml
type sentence = (mytype list[@random random_list ~min:2 ~empty:0.6 random_mytype])
[@@deriving arsenal]
```
The keyword `list` is followed by `[@random random_list ~min:2 ~empty:0.6 random_mytype]` in order to specify that, when randomly
generating the list,
- the `random_mytype` function is used to generate each item of the list
- the list should have at least two elements (`~min:2`)
- after that, generate the list step-by-step from head to tail, with, at each step, the probability `0.6` to stop the list.

There is a function `random_bool` to generate `true` or `false` with uniform probability

There is a function `random_int` to generate an integer between 0 and 10.

You can look in [`arsenal_lib.ml`](../ocaml-grammars/arsenal_lib/src/arsenal_lib.ml) to see what other primitives are available.

#### Entity Types

To understand how how a model can be trained to withstand occasional misclassification of entities, consider
the following sample grammar used to analyze restaurant reviews:

 ```ocaml
 type kind =
   | LocationMention
   | FoodItemMention
   | RecipeMention
   | CookingMethodMention
   | MeasurementAnnotation
 [@@deriving arsenal, show { with_path = false }]
 ```
As a reminder, this declaration declares the generic type `kind` of an entity kind and assigns it to any of the six
specific types of mention corresponding to keywords identified by a hypothetic restaurant review entity processor.

At the leaves of syntax trees, we may wish to have the specific entity placeholders
such as `RecipeMention_3` that we see in the input of the NL to CST module.
These leaves will all be of a generic type called `kind Entity.t`, whether they are of specific type `RecipeMention_3`, `LocationMention_42`, or `FoodItemMention_38`, etc.

The fact that they inhabit the same type will help the NL to CST module to be
robust to misclassifications by the Entity Processor: indeed, parsing
`RecipeMention_3` while expecting to parse a location will not lead to a
grammatical error, because the grammar's hard rule is in fact to expect a tree
of type `kind Entity.t`. However, it is still useful to train the NL to CST model
so that it doesn't treat recipes and locations in the same way, in that, when
parsing `RecipeMention_3`, the model should consider it a recipe with
high probability without making it a hard rule: with low probability it
should understand that it could be a location mistakingly classified as a recipe.
In order to achieve that, we tune the synthetically generated data accordingly:
Namely, whenever we generate a food item, we will most often generate a leaf tree
of the form `FoodItemMention_xx`, but from time to time, we stick
`RecipeMention_yy` in there, just so that model is exposed, during
training, to misclassified entities.

This is achieved in the grammar file by identifying a type `food`, with the following declaration:

```ocaml
type food  = (kind[@random pick food]) Entity.t
[@@deriving arsenal]
```
The `[@random pick food]` is indicating that, whenever a leaf tree
inhabiting type `food` should be generated, the random generation should pick
an entity placeholder (i.e. an inhabitant of type `kind`) according to the
probability distribution called `food`.

To extend our example above, the probability distribution
called `food` could be defined as follows:

```ocaml
let food : kind distribution =
  [ LocationMention, 2.;
    FoodItemMention, 8.;
    RecipeMention, 6.;
    CookingMention, 2.;
    MeasurementAnnotation, 1. ]
```
It is a distribution over elements of type `kind`, which gives the biggest
weight to `FoodItemMention`, but also allows other placeholders to be
generated with lower probabilities, thereby emulating in the generated data
misclassifications of entities.
The actual probabilities are not (a normalised version of) `2., 8., 6., 2., 1`., but
(the normalised version of) `2.^x, 8.^x, 6.^x, 2.^x, 1.^x`,
where `x` is a global command-line argument specified by the user when invoking the random generator.
Setting `x` to `0.0` will make all placeholder kinds equiprobable.
Setting it to a very high value will make the probability of the heaviest kind
(here `FoodItemMention`) tend to `1`, while the others will be drowned.
See the option in the help of the generator command.

## The Pretty-Printing File

- [Overview](#overview-pretty-printing)
- [Standard printing](#standard-printing)
- [Accessing sub-trees](#accessing-sub-trees)
- [Randomised pretty-printing](#randomised-pretty-printing)
- [Pretty-printing entities](#pretty-printing-entities)
- [Passing more information to recursive calls](#passing-more-information-to-recursive-calls)

### <a name="overview-pretty-printing"></a> Overview

The purpose of the pretty-printing file is to provide a function that takes a syntax
tree and turns it into an NL sentence. That file is dependent on the grammar
file because it makes references to it (in the build system, it is loaded after
the grammar file).

For instance, to provide NL renderings for syntax trees of type `re` (the 
top-level type of the RE grammar, specified in the file `REgrammar.ml`), one can call 
function

```ocaml
pp_re
```
on arguments `fmt` and `st`, where `fmt` is the buffer where the output string
has to be written and `st` is the syntax tree to be pretty-printed. That
function itself, implemented in file `src/REgrammar_pp.ml`, has type `re pp`,
the type of pretty-printers for syntax trees of type `re`.

A type `mytype pp` is an abbreviation (defined in file
[`arsenal_lib.ml`](../ocaml-grammars/arsenal_lib/src/arsenal_lib.ml) for type `formatter -> mytype -> unit`, which
describes the signature of a function taking as inputs a formatting buffer, an
element of type `mytype`, and not returning any value (but rather
pretty-printing the element into the buffer).

The implementation of `pp_re` in the pretty-printing file therefore starts with

```ocaml
let rec pp_re fmt = function
  ...
```
where `let` is a keyword introducing a definition, `rec` is a keyword indicating that what is being defined is a recursive function (it can call itself), `fmt` is the (first) argument of the function (of type `formatter`), `=` introduces the body of the definition, which in this case is a function taking as argument the syntax tree to pretty-print.

Note that we could have picked an arbitrary name for the pretty-printing
function `pp_re`; but it is a standard convention to give a
pretty-printing function for type `mytype` the name `pp_mytype`.

As one can imagine, pretty-printing a syntax tree of type `re` relies on
the ability to pretty-printing each of its subtrees, which can be of different
types involved in the grammar. Therefore, for each type `mytype` declared in the
grammar file, there must be a pretty-printing function, conventionally called
`pp_mytype` in the pretty-printing file.

### Standard printing

The standard way to define a pretty-printing function with buffer argument `fmt`
and syntax tree argument `st` is a line of the form

```ocaml
fprintf fmt "SOME_STRING" [POSSIBLY_SOME EXTRA_ARGUMENTS]
```
where `"SOME_STRING"` is a string describing the NL for that tree. 
Special escape characters can be used in that string to declare holes, with the extra arguments of fprintf indicate how to fill the holes.
We will detail four escape characters (more can be found at https://caml.inria.fr/pub/docs/manual-ocaml/libref/Printf.html#VALfprintf).

The escape character `%i` indicates a hole that will be filled by an integer; the integer is given as an extra argument, as in:

```ocaml
fprintf fmt "I ate %i cookies for breakfast" number_of_cookies
```

The escape character `%s` indicates a hole that will be filled by a string; the string is given as an extra argument, as in

```ocaml
fprintf fmt "I ate 3 %s for breakfast" cookies_or_biscuits
```

The escape character `%a` indicates a hole that will be filled by another pretty-printing function, applied on another syntax tree (typically, the children of the tree we want to pretty-print). The pretty-printing function to be used, as well as that syntax tree, are given as extra arguments, as in

```ocaml
fprintf fmt "I ate 3 cookies for %a" pp_meal the_meal_in_question
```

Finally, the escape character `%t` indicates a hole that will be filled by another pretty-printing function that does not take any argument (other than the out buffer). The pretty-printing function to be used will be of type `print`, defined in file [`arsenal_lib.ml`](../ocaml-grammars/arsenal_lib/src/arsenal_lib.ml) as an abbreviation for
`formatter -> unit`, and is given here as an extra argument, as in

```ocaml
fprintf fmt "I %t 3 cookies for breakfast" pp_eating_verb
```

Obviously, one can use as many escape characters as needed, and write:

```ocaml
fprintf fmt "I %t %i %s for %a" pp_eating_verb number_of_cookies cookies_or_biscuits pp_meal the_meal_in_question
```


### Accessing sub-trees

When implementing the pretty-printing function `pp_mytype` for type `my_type`,
it is useful to make a case analysis on the constructor labelling the root node of the syntax tree to be printed.
If the declaration of `my_type` in the grammar file is

```ocaml
type mytype = C_one | C_two of othertype*othertype | C_three of othertype*mytype
```
Then the pretty-printing function will typically be of the form:

```ocaml
let rec pp_mytype : mytype pp = fun fmt st ->
  match st with
  | C_one -> ...
  | C_two(child1,child2) -> ...
  | C_three(child1,child2) -> ...
```
Three distinct pretty-prints (typically using `fprintf fmt ...`) can be defined corresponding to the three cases, and
`child1` and `child2` can be used in the corresponding branch of the case analysis.
Note that the keyword `rec` is needed if in the case of `C_three(child1,child2)`, one wants to recursively use function `pp_mytype` to pretty-print `child2`, which is also of type `mytype`.

### Randomised pretty-printing

What we have seen so far about pretty-printing allows us to translate any syntax
tree to *one* natural language rendering of it. But note that one of the
objectives of the syntax tree generator and pretty-printing is to produce an
arbitrarily large set of labelled data (NL + syntax tree) that will be used to
train a machine learning model to perform the opposite task, namely translate an
NL sentence into a syntax tree. If for each syntax tree there were only *one*
way to write it in natural language, the model would not be very robust: it
would need to read exactly that sentence to figure out which syntax tree it is.
Here, we want to capture the fact that, in natural language, there is often more
than one way of saying something. For this, the model needs to have seen, during
its training, many ways of expressing, in NL, the same syntax tree. We therefore
allow the randomisation of the pretty-printing functions so that, every time
such a function is called, on a given input syntax tree, it produces at random
one of the many ways to say it in NL. Since the labelled dataset is produced by
generating about a million random syntax trees and random NL pretty-printings,
the model will be exposed during training, to the many ways natural language
expresses the concepts and relations encoded in the grammar.

Randomising the pretty-printing is pretty simple:
wherever we used to write 
```ocaml
fprintf fmt "SOME_STRING" [POSSIBLY_SOME_EXTRA_ARGUMENTS]
```
to describe *one* way of expressing the grammar node in NL,
we now write
```ocaml
!??[
    lazy (fprintf fmt "SOME_STRING1" [POSSIBLY_SOME_EXTRA_ARGUMENTS]), WEIGHT1;
    lazy (fprintf fmt "SOME_STRING2" [POSSIBLY_SOME_EXTRA_ARGUMENTS]), WEIGHT2;
    lazy (fprintf fmt "SOME_STRING3" [POSSIBLY_SOME_EXTRA_ARGUMENTS]), WEIGHT3;
    ...
    lazy (fprintf fmt "SOME_STRINGn" [POSSIBLY_SOME_EXTRA_ARGUMENTS]), WEIGHTn;
]
```
enumerating n different ways of pretty-printing the tree node. The weights are
integers that define the probabilities with which the n different ways should be
picked: when called once, the pretty-printing function will pick one of them at
random, with such probabilities. Note the addition of the keyword `lazy`:
without it, the pretty-printing function would, first, generate the different NL
sentences for the (whole) tree, and then pick one of them according to the
probabilities. That would be far too slow. `lazy` means that each of the
described renderings is not computed right away: the random pick is first
performed according to the probabilities, and only then is the computation of
the full sentence performed, for the picked rendering only (and not the others).

When the weights are all equal (i.e. the probability law is uniform), the
following abbreviation of the above can be used:
```ocaml
!?[
    lazy (fprintf fmt "SOME_STRING1" [POSSIBLY_SOME_EXTRA_ARGUMENTS]);
    lazy (fprintf fmt "SOME_STRING2" [POSSIBLY_SOME_EXTRA_ARGUMENTS]);
    lazy (fprintf fmt "SOME_STRING3" [POSSIBLY_SOME_EXTRA_ARGUMENTS]);
    ...
    lazy (fprintf fmt "SOME_STRINGn" [POSSIBLY_SOME_EXTRA_ARGUMENTS]);
]
```
An example of the above in `REgrammar_pp.ml` is
```ocaml
let pp_terminal fmt = function
  | Specific s -> !?[
      lazy (fprintf fmt "the string %a" pp_tstring s);
      lazy (fprintf fmt "string %a" pp_tstring s);
    ]
  | Empty    -> !?[
      lazy (fprintf fmt "an empty string");
      lazy (fprintf fmt "the empty string");
      lazy (fprintf fmt "an empty word");
      lazy (fprintf fmt "the empty word");
    ]
  | CharacterRange(a,z) -> !?[
      lazy (fprintf fmt "a character between %a and %a" pp_tchar a pp_tchar z);
      lazy (fprintf fmt "any character between %a and %a" pp_tchar a pp_tchar z);
    ]
...

When the n different renderings are simple strings, rather than some `fprintf`
call that may trigger some heavy computation (pretty-printing the subtrees, etc),
the `lazy` keyword is not warranted, and one can simply write:
```ocaml
!!![
    "SOME_STRING1", WEIGHT1;
    "SOME_STRING2", WEIGHT2;
    "SOME_STRING3", WEIGHT3;
    ...
    "SOME_STRINGn", WEIGHTn;
]
```
and when the weights are all equal:
```ocaml
!![
    "SOME_STRING1";
    "SOME_STRING2";
    "SOME_STRING3";
    ...
    "SOME_STRINGn";
]
```

A few quick things to memorize about the operators `!??`, `!?`, `!!!`, `!!` above are that:
- they all start with `!`
- 3-character operators require explicit weights; 2-character ones make uniform picks
- the possible third character is always the same as the second
- `!!` and `!!!` are simpler than `!?` and `!?`, so the former deal with the simple case
  of pure strings, while the latter deal with the more complicated case of lazy `fprintf`

Look at the file [`arsenal_lib/src/base_grammar.ml`](../ocaml-grammars/arsenal_lib/src/base_grammar.ml) for the list of available operators.

### Pretty-printing entities

If the grammar terminal is defined as an entity with an expression such as
```ocaml
type myterminal  = (kind[@random SOME_RANDOM_GENERATION_INSTRUCTION]) Entity.t
```
An easy pretty-printer for that type is
```ocaml
let pp_myterminal : myterminal pp = Entity.pp pp_kind
```
An example of this in `REgrammar.ml` is:
```ocaml
type tstring = kstring Entity.t [@@deriving arsenal]
```
with pretty-printer in `REgrammar_pp.ml`
```ocaml
let pp_tstring = Entity.pp pp_kstring
```

### Passing more information to recursive calls

Sometimes when pretty-printing a syntax tree as a sentence, one would like to
pretty-print its children in specific way: for instance if the subject of the
sentence to be produced is plural, then the verb to be pretty-printed also needs
to be plural. In other words, the pretty-printing of the subject and the
pretty-printing of the verb have to agree. It is therefore useful to be able to
pass some information to pretty-printing functions.

In order to do that, a pretty-printing function for type `mytype` to which one
can pass extra information will be of the form
```ocaml
let pp_mytype : (ARG_TYPE,sentence) spp = fun arg fmt st ->
  ...
```
instead of the plain
```ocaml
let pp_mytype : sentence pp = fun fmt st ->
  ...
```

The end of the line `fun arg fmt st ->` features a new argument `arg` which is
the extra information that the function takes as argument. Correspondingly, the
type of the function is no longer `mytype pp`, but `(ARG_TYPE,mytype) spp`,
which is an abbreviation (defined in the [`arsenal_lib.ml`](../ocaml-grammars/arsenal_lib/src/arsenal_lib.ml) file) for type
`ARG_TYPE -> formatter -> mytype -> unit`, and where `ARG_TYPE` is the type of
the extra argument `arg`. Of course when calling `pp_mytype`, one shouldn't
forget to pass the extra information as argument, writing `(pp_mytype SOME_ARG)`
instead of `pp_mytype`.

The following pretty-printing example function takes
an extra argument `state` of type `noun`. In this case, the extra argument is a
record with a Boolean field `noarticle`. If that Boolean is true, then whoever
has called function `pp_food_noun` does not want its output to have an
article, otherwise it can. The definition of `pp_food_noun` makes a case
analysis on that boolean in order to print the article or not:
```ocaml
let pp_food_noun : (noun,food_noun) spp = fun state fmt (FoodNoun(t,d)) ->
  !??[
    lazy (fprintf fmt "%a%a" pp_food_type t pp_food d),3;
    lazy (fprintf fmt "%s%acase of %a"
            (if state.noarticle then "" else "a ")
            pp_food_type t
            pp_food d),1;
  ]
```
You would not refer to "a toast" as a food item, but instead, use "toast".

## Conclusion

While the `.ml` grammar file basically contains no executable code (it mainly
defines the grammar as a series of type declarations), the `.ml` file for
pretty-printing defines the natural language rendering of syntax trees by coding
pretty-printing functions. 
