# Understanding Concrete Syntax Trees in Arsenal

- [Introduction](#introduction)
- [Nodes](#nodes)
- [Nodes and Arities](#nodes-and-arities)
- [Types of Node](#types-of-node)
  - [Entity Nodes](#entity-nodes)
  - [Nodes of a Built-In Type](#nodes-of-a-built-in-type)
  - [Option Nodes](#option-nodes)
  - [List Nodes](#list-nodes)
- [A Complete CST and its Interim S-Expression](#a-complete-cst-and-its-interim-s-expression)
- [Conclusion](#conclusion)
 

## Introduction

Arsenal takes input that is natural language text and generates output that is Concrete Syntax Trees (CSTs) represented in [JSON](https://json.org/).  The structure of the CST is determined by a defined grammar and a model trained on that grammar.  The model is trained on sentences generated by "pretty-printing" functions that follow the grammar but also include selectively randomized variants.

Understanding Arsenal output syntax and how that syntax depends on grammar definitions is necessary for knowing how to interpret output for use as part of a larger system.

The definition of syntax trees in Arsenal allows for an unbalanced tree with a variable number of subtree child nodes, the details of which are defined in the grammar. 

## Nodes

An Arsenal node is represented as a JSON dictionary, with dictionary items that are key-value pairs for:
- the **label** of the node 
- the **type** of the node 
- a list containing the **subtrees**, "children", or "child nodes" of the node

For example:
```json
{
  "node": "ReviewOf",
  "type": "sentence_unit",
  "subtrees": [...]
}
```

## Nodes and Arities

An Arsenal node can have an arbitrary number of children, but the number of children is fixed for each node label, and is called the *arity* of the label.  So a tree whose root is a node with label `a` of arity 2 has the form:
```json
{
  "node": "a", 
  "type": "a-type", 
  "subtrees": [ <subtree_one>, <subtree_two> ] 
}
```
But a tree whose root is a node with label `b` of arity 1 has the form:
```json
{
  "node": "b", 
  "type": "b-type", 
  "subtrees": [ <subtree_one> ] 
}
```
A tree whose root is a node with label `c` of arity 0 will be:
```json
{
  "node": "c", 
  "type": "c-type", 
  "subtrees": []
}
```
Such a node is a *leaf* in the tree, with no subtrees.

## Types of Node

### Entity Nodes

When the node label for a leaf in the tree is an entity, it is labeled with a dictionary whose items include the entity placeholder and the original text for which the placeholder was substituted.  For example, for an entity of specific type `FoodItemMention_1` replacing the text `cabbage`:
```json
{
  "node": {
    "placeholder": "FoodItemMention_1",
    "text": "cabbage"
  },
  "type": "entity<kind>",
  "subtrees": []
}
```

### Nodes of a Built-In Type

For nodes of a built-in type - e.g. `boolean`, `option`, or `list` - the JSON representation of the node is simplified.  Rather than having dictionaries like the user-defined nodes shown above, the JSON representation of a node of a built-in type simply has the value of the type.  For example, the representation of a `boolean` type node in a list would be: 
```json
[
  false
]
```
rather than:
```json
[
  {
    "node": false,
    "type": "boolean",
    "subtrees": []
  }
]
```

### Option Nodes

For an `option` node - which is by definition optional - if a subtree isn't present, the JSON node is simply `null`. For instance a list of two arguments, the first of which is optional, could be this:

```json
[
  null,
  {node-in-subtree}
]
```

### List Nodes

For a list node, if the subtrees in the list are subtree_1..subtree_n, then the JSON representation is simply `[subtree_1,..,subtree_n]`.
The list itself is not encapsulated in a node dictionary.

Arsenal grammar supports lists of arbitrary length, and when the CST has a node of a type that requires list arguments, the list argument values are also represented in the tree even if they're empty. 
As an example, if there were a definition for a `DQ` "descriptively qualified" label like this:
```ocaml
type 'a descriptively_qualified =
    DQ of (adjective list[@random random_list ~min:0 ~empty:0.9 random_adjective])
          * 'a
```

This requires a list of adjectives `list<adjective>` as the first argument. Note that the `@random` notation and other notations in the list definition apply to pretty-printing functions that print sentences for training data.  See for more information, see [Extending a Grammar](Extending-a-Grammar.md).

For the CST for a part of a sentence with no adjectives, the JSON represenation would be as follows:
```json
{
  "node": "DQ",
  "type": "descriptively_qualified<entity<kind>>",
  "subtrees": [
    [],
    {<node-in-subtree>}
  ]
}
```
The JSON `[]` represents the empty list of adjectives.


But for an adjective "spicy" for the entity `FoodItemMention` of "cabbage", the JSON represenation would instead be as follows:
```json
{
  "node": "DQ",
  "type": "descriptively_qualified<entity<kind>>",
  "subtrees": [
    [
      {
        "node": "spicy",
        "type": "adjective",
        "subtrees": []
      }
    ],
    {
      "node": {
        "placeholder": "FoodItemMention_5",
        "text": "cabbage"
      },
      "type": "entity<kind>",
     "subtrees": []
    }
  ]
}
```

While the CST doesn't contain any type information for empty lists and null nodes, for debugging it is possible to look at the interim S-expression format of the sentence before the placeholder substitutions have been added back in.  This output is available as part of the `stderr` output from the `nl2cst_1` process.  In the part of the  CST above, it looked like this:

```ocaml
( DQ:descriptively_qualified<entity<kind>>
  ( List:list<adjective>
    ( Frequent:adjective )
  )
  ( FoodItemMention_5:entity<kind> )
)
```

Another list example from a hypothetical restaurant review defined grammar to the CST representation is shown at the top of any CST for a processed sentence.  
The grammar definition would be:

```ocaml
type sentence = (sentence_unit list[@random random_list ~min:1 ~empty:0.6 random_sentence_unit])
```

As the entry type is a list of sentence units, the top-level JSON representation of the "cst" starts as a list type `[]`.

```json
{
  "cst": [
  {
    "node": "ReviewOf",
    "type": "sentence_unit",
    "subtrees": []
  }
  ]
}
```

## A Complete CST and its Interim S-Expression
The detailed output from the following sentence is based on the regular expression demo using the `regexp_2019-09-26` model in the `regexp/models` directory and the currently-defined [`REgrammar.ml`](../regexp/generate-reformulate/src/REgrammar.ml).

```english
either the string "abc" or any digit or any single character between 'p' and 'r'
```

Given the following grammar definition for the `re` type in [`REgrammar.ml`](../regexp/generate-reformulate/src/REgrammar.ml)`:
```ocaml
type terminal =
  | Specific of tstring [@weight 10]
  | Empty
  | CharacterRange of tchar*tchar [@weight 4]
  | Word | Any | Digit | Space | NotWord | NotDigit | NotSpace
[@@deriving arsenal]

type re = Terminal of terminal [@weight fun state -> 2. *. depth state ]
        | StartOfLine of re
        | EndOfLine of re
        | Plus of re
        | Star of re
        | Or of re*re
        | Concat of (re list[@random random_list ~min:2 random_re])
[@@deriving arsenal]
```                  
the interim S-expression is as follows:
```ocaml
( Or:re 
  ( Or:re 
    ( Terminal:re 
      ( Specific:terminal 
        ( String_1:entity<kstring> ) 
      ) 
    ) 
    ( Terminal:re 
      ( Digit:terminal ) 
    ) 
  ) 
  ( Terminal:re 
    ( CharacterRange:terminal 
      ( Char_1:entity<kchar> ) 
      ( Char_2:entity<kchar> ) 
    ) 
  ) 
) 
```

This interim S-expression is then represented as the following CST after matching the original text values to the placeholders:
```json
{
  "sentences": [
    {
      "id": "S1",
      "nl": "either the string String_1 or any digit or any single character between Char_1 and Char_2",
      "cst": {
        "node": "Or",
        "type": "re",
        "subtrees": [
          {
            "node": "Or",
            "type": "re",
            "subtrees": [
              {
                "node": "Terminal",
                "type": "re",
                "subtrees": [
                  {
                    "node": "Specific",
                    "type": "terminal",
                    "subtrees": [
                      {
                        "node": {
                          "placeholder": "String_1",
                          "text": "\"abc\""
                        },
                        "type": "entity<kstring>",
                        "subtrees": []
                      }
                    ]
                  }
                ]
              },
              {
                "node": "Terminal",
                "type": "re",
                "subtrees": [
                  {
                    "node": "Digit",
                    "type": "terminal",
                    "subtrees": []
                  }
                ]
              }
            ]
          },
          {
            "node": "Terminal",
            "type": "re",
            "subtrees": [
              {
                "node": "CharacterRange",
                "type": "terminal",
                "subtrees": [
                  {
                    "node": {
                      "placeholder": "Char_1",
                      "text": "'p'"
                    },
                    "type": "entity<kchar>",
                    "subtrees": []
                  },
                  {
                    "node": {
                      "placeholder": "Char_2",
                      "text": "'r'"
                    },
                    "type": "entity<kchar>",
                    "subtrees": []
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  ]
}
```


The CST above is an example of how one regular expression is represented based on the defined grammar. 
To run more example regular expressions and view the associated output, see the demo documentation at [`README.md`](../regexp/README.md).

## Conclusion

For any defined grammar, a CST parser, which also has access to the grammar, could walk the tree looking for the grammar-defined components.
These captured components could then be applied as part of a larger system - such as logical rules for machine learning, or structured data for analysis.
If the grammar cannot capture all of the necessary information from the language, the grammar might require extensions after which you would generate a new Arsenal model for runtime. For more information about how to do this, see [Extending a Grammar](Extending-a-Grammar.md) and [Training a Model](Training-a-Model.md).

